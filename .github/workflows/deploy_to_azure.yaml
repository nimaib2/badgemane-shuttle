name: Deploy Flask App to Azure Container Instance

on:
  push:
    branches:
      - main # Trigger on push to the main branch

env:
  # Azure Container Registry details
  ACR_NAME: ${{ secrets.ACR_NAME }}
  IMAGE_NAME: nimaib/myflaskapp-amd-062501 # Your image name (part after the ACR name)
  IMAGE_TAG: ${{ github.sha }} # Use git SHA for unique image tag
  ACTIONS_STEP_DEBUG: true # Add this line for debugging
  ACTIONS_RUNNER_DEBUG: true
  
  # Azure Container Instance details
  ACI_NAME: myflaskapp-instance # Consistent name for your ACI
  ACI_DNS_LABEL: myflaskapp-webhook # Consistent DNS label for your ACI
  ACI_REGION: westus # Change to your preferred Azure region (e.g., westus, centralus)
  ACI_PORT: 5000 # The port your Flask app listens on inside the container
  
permissions:
  id-token: write # Required for Azure OIDC login
  contents: read # Required to checkout code

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production # Optional: define an environment for deployment  tracking

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      id: azure-login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Debug OIDC Token Subject
      run: |
        echo "Raw OIDC Token: ${{ steps.azure-login.outputs.access_token }}"
        TOKEN=$(echo "${{ steps.azure-login.outputs.oidc_token }}" | cut -d'.' -f2 | base64 --decode)
        echo "OIDC Token Payload:"
        echo $TOKEN | jq .
        echo "OIDC Token Subject (sub): $(echo $TOKEN | jq -r .sub)"
        echo "This is the 'subject' that Azure AD is expecting in your federated credential."

    - name: Docker Login to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.ACR_NAME }}.azurecr.io
        username: ${{ secrets.AZURE_CLIENT_ID }}
        password: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IkFNTDU6UUNMWjpCRDQ1OkRSRDI6RkdESTo3Q1NGOkdVUEI6V1RWQTpVVUtJOjRKN1Y6Mjc0QTpQSkRVIn0.eyJqdGkiOiIzOWZiNzFjNC1kYTcwLTRlNjItODQ0Ny05NjI1MGVhYjQwMTMiLCJzdWIiOiJuaW1haWJAdXcuZWR1IiwibmJmIjoxNzUxMDY5MzYzLCJleHAiOjE3NTEwODEwNjMsImlhdCI6MTc1MTA2OTM2MywiaXNzIjoiQXp1cmUgQ29udGFpbmVyIFJlZ2lzdHJ5IiwiYXVkIjoic2h1dHRsZS1oN2N0ZjJhdGJnZzljZ2czLmF6dXJlY3IuaW8iLCJ2ZXJzaW9uIjoiMS4wIiwicmlkIjoiNzI5OTc3NDg2YmJkNDMzYjgwZTM2ODk2ODExM2VlNjIiLCJncmFudF90eXBlIjoicmVmcmVzaF90b2tlbiIsImFwcGlkIjoiYjY3N2MyOTAtY2Y0Yi00YThlLWE2MGUtOTFiYTY1MGE0YWJlIiwidGVuYW50IjoiZjZiNmRkNWItZjAyZi00NDFhLTk5YTAtMTYyYWM1MDYwYmQyIiwicGVybWlzc2lvbnMiOnsiYWN0aW9ucyI6WyJyZWFkIiwid3JpdGUiLCJkZWxldGUiLCJtZXRhZGF0YS9yZWFkIiwibWV0YWRhdGEvd3JpdGUiLCJkZWxldGVkL3JlYWQiLCJkZWxldGVkL3Jlc3RvcmUvYWN0aW9uIl19LCJyb2xlcyI6W119.BDKzqJCycGe86U8ZFRcvkYqbFeNFc60pttzId4p8imdvaPVh3hcSywPQERg2KPh69aCj-TiRZKBZ4QZiI2sJm23rpmQF0XmPZjOhU3LMglZ4iHZP5B0FuH_MmraD8gFd7HC4bIF2VHbKQf0Let_5ZTqhD0w9eZ87dPgEylluooQ9A2Rz2CvsCrKj3YUQZZe5IPh-r02Go4JwewiR2Pgeb6XlyUcoAI0u5cHzd6FrDRDDvgrUMcqdmNuq5AUW5-t-8MF85lpFOjRGrI6kvUIjaoMQx3TTZNjI4MJYV0MX_qEqTBqRZfwE1k9-hfbcEGcPhjbhbBg1WPmBPj9ZozwaXw

    - name: Build and Push Docker image to ACR
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        platforms: linux/amd64 # Ensure correct architecture for builds

    - name: Delete existing Azure Container Instance (if it exists)
      # The "|| true" ensures the workflow doesn't fail if the ACI doesn't exist yet
      run: |
        az container delete \
          --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.ACI_NAME }} \
          --yes --no-wait || true
        echo "Waiting for ACI deletion to propagate..."
        sleep 30 # Give Azure time to process the deletion

    - name: Create new Azure Container Instance
      run: |
        az container create \
          --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.ACI_NAME }} \
          --image ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
          --dns-name-label ${{ env.ACI_DNS_LABEL }} \
          --ports ${{ env.ACI_PORT }} \
          --cpu 1 \
          --memory 1.5 \
          --os-type Linux \
          --restart-policy OnFailure \
          --location ${{ env.ACI_REGION }} \
          --environment-variables \
            ACCOUNT_SID="${{ secrets.TWILIO_ACCOUNT_SID }}" \
            AUTH_TOKEN="${{ secrets.TWILIO_AUTH_TOKEN }}" \
            SUPABASE_URL="${{ secrets.SUPABASE_URL }}" \
            SUPABASE_KEY="${{ secrets.SUPABASE_KEY }}"

    - name: Get FQDN of the new Container Instance
      run: |
        FQDN=$(az container show \
          --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.ACI_NAME }} \
          --query 'ipAddress.fqdn' \
          --output tsv)
        echo "Azure Container Instance deployed. FQDN: ${FQDN}"
        echo "You can set your Twilio webhook URL to: http://${FQDN}:${{ env.ACI_PORT }}/webhook"
